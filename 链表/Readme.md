### 模板单链表如何写：

1. Node设计为内部类的原因：用同一个模板。（但是好像不是同一个也没什么问题。）
2. createNode() : 使用new来创建Node对象，才能不随着函数消亡。
3. insert() : 头插要改变_head的指向，所以index==0时要单独考虑。
4. erase() : 头删要改变_head的指向，所以index==0时要单独考虑。
小细节：
为什么插入和删除时没单独考虑size==0的情况？
erase() 中 if(index >= size || index < 0) 在 else if(index == 0)前面，
这样当没有节点时即size==0时被一并处理掉了。insert() 中也是同样的考虑。

### 模板 + 内部类 + 抛异常
 3.抛异常 ：
 3.1 catch{}处理完异常后，程序继续执行函数中try-catch结构之后的代码，
     而不是直接退出函数。(除非在catch块中已经退出）
     捕获异常的一大特点就是：程序不再随着异常的出现而终止。
     当异常被throw时，函数并不是“正常”地退出，而是由于异常而提前退出。
 4.类的隐式类型转换：
     构造函数不仅可以构造与初始化对象，对于只有一个参数或只有第一个参数没有缺省值和全缺省的构造函数，还具有类型转换的作用。
     可以通过explicit关键字来禁止这种隐式类型转换。
 5.默认构造函数的作用：
     最好给类加一个默认构造函数，这样才方便成为别的类的成员。
     对象创建时：内部的自定义类型成员也要创建，如果构造函数的初始化列表中没有显示调用其构造函数
                 这个时候就要调用它们的默认构造函数。
 6.const成员函数：
     const 对象无法使用非const函数，this指针会导致权限放大，会直接报错。
     所以get方法要写成const函数。
 7.总结：自定义类型成员的类中要有：
     a. 默认构造函数(方便成为别的类的成员）
     b. 赋值运算符重载(防止浅拷贝，不怕浅拷贝的可以不写）

### 问题记录：

 1. 在形参表中不匹配。
    变量名，函数名写错 --_--||| 。 
    记住C++中私有的成员变量前带了一个下划线。访问对象成员最好带一个this，这样编译器就会检查有没有这个对象。 

 2. 对象指针和成员
    对象指针用->来访问成员。

 3. 对象与成员函数类型不兼容
    const 对象无法使用非const函数，会导致权限放大，会直接报错。
    get方法要写成const函数。

 4. 没有合适的默认构造函数可用
    类中的自定义成员对象是要用默认构造函数来创建的
    虽然可以在初始化列表中显示调用构造函数，但万一是模板类呢？
    所以最好给类加一个默认构造函数，这样才方便成为别的类的成员。